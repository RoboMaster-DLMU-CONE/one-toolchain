name: Build Toolchain

on:
  push:
    tags: ['v*']

  workflow_dispatch: 

jobs:
  build:
    name: Build for ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: windows-latest
            arch: x86_64
            asset_name: one-toolchain-windows-x64.zip
            artifact_name: one-toolchain-windows-x64
            python_asset: python-3.12.x-embed-amd64.zip
          - os: ubuntu-latest
            arch: x86_64
            asset_name: one-toolchain-linux-x64.tar.gz
            artifact_name: one-toolchain-linux-x64
          - os: macos-latest
            arch: x86_64
            asset_name: one-toolchain-macos-x64.tar.gz
            artifact_name: one-toolchain-macos-x64
          - os: macos-latest
            arch: aarch64
            asset_name: one-toolchain-macos-arm64.tar.gz
            artifact_name: one-toolchain-macos-arm64

    steps:
      - uses: actions/checkout@v4

      # 1. Resolve Python asset (Windows embed or python-build-standalone)
      - name: Resolve Python asset
        id: resolve-python
        uses: actions/github-script@v6
        env:
          MATRIX_OS: ${{ matrix.os }}
          MATRIX_ARCH: ${{ matrix.arch }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const os = (process.env.MATRIX_OS || '').toLowerCase();
            const arch = (process.env.MATRIX_ARCH || '').toLowerCase();
            const targetMinor = '3.12';
            async function run() {
              if (os.startsWith('win')) {
                // Use fixed Python 3.12.10 for Windows
                const version = '3.12.10';
                const python_key = `python-${version}-embed-amd64.zip`;
                const python_url = `https://www.python.org/ftp/python/${version}/${python_key}`;
                core.setOutput('python_key', python_key);
                core.setOutput('python_url', python_url);
                return;
              }

              // Unix: prefer python-build-standalone assets that contain 3.12 and install_only
              const rel = await github.rest.repos.getLatestRelease({ owner: 'astral-sh', repo: 'python-build-standalone' });
              const assets = rel.data.assets || [];
              const candidates = assets.filter(a => /install_only/.test(a.name) && a.name.includes(targetMinor));
              const archTags = arch === 'aarch64' ? ['aarch64','arm64'] : ['amd64','x86_64','amd64'];
              let asset = candidates.find(a => archTags.some(tag => a.name.includes(tag)) && (os.includes('mac') ? a.name.includes('darwin') : a.name.includes('linux')));
              if (!asset) asset = candidates.find(a => os.includes('mac') ? a.name.includes('darwin') : a.name.includes('linux'));
              if (!asset && candidates.length) asset = candidates[0];
              if (asset) {
                core.setOutput('python_key', asset.name);
                core.setOutput('python_url', asset.browser_download_url);
                return;
              }

              // Fallback: try any install_only asset (latest release)
              const fallback = assets.filter(a => /install_only/.test(a.name));
              let asset2 = fallback.find(a => archTags.some(tag => a.name.includes(tag)) && (os.includes('mac') ? a.name.includes('darwin') : a.name.includes('linux')));
              if (!asset2) asset2 = fallback.find(a => os.includes('mac') ? a.name.includes('darwin') : a.name.includes('linux'));
              if (asset2) {
                core.setOutput('python_key', asset2.name);
                core.setOutput('python_url', asset2.browser_download_url);
                return;
              }

              // No asset found
              core.setOutput('python_key', '');
              core.setOutput('python_url', '');
            }
            run().catch(err => core.setFailed(err.message));
      - name: Setup Portable Python (Windows)
        if: ${{ startsWith(matrix.os, 'windows') }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $url = "${{ steps.resolve-python.outputs.python_url }}"
          $key = "${{ steps.resolve-python.outputs.python_key }}"
          Write-Host "Downloading $url"
          Invoke-WebRequest -Uri $url -OutFile "$PWD\$key"
          Write-Host "Extracting Python embeddable zip: $key"
          # 首先解压到临时目录
          Expand-Archive -Path "$PWD\$key" -DestinationPath "$PWD/temp_python" -Force

          # 诊断：查看临时目录内容
          Write-Host "Contents of temp_python directory:"
          $tempItems = Get-ChildItem "$PWD/temp_python" -Recurse
          foreach ($item in $tempItems) {
              if ($item.PSIsContainer) {
                  Write-Host "  [DIR]  $($item.FullName.Replace("$PWD\temp_python\", ''))"
              } else {
                  Write-Host "  [FILE] $($item.Name)"
              }
          }

          # 确保目标目录存在
          if (!(Test-Path "$PWD/dist/python")) {
              New-Item -ItemType Directory -Path "$PWD/dist/python" -Force | Out-Null
          }

          # 获取临时目录中的项目
          $items = Get-ChildItem "$PWD/temp_python"
          Write-Host "Found $($items.Count) items in temp directory"

          if ($items.Count -eq 1 -and $items[0].PSIsContainer) {
              Write-Host "Found nested directory structure, moving contents from $($items[0].Name)"
              $sourcePath = "$PWD/temp_python/$($items[0].Name)"
              Get-ChildItem -Path $sourcePath | Move-Item -Destination "$PWD/dist/python/" -Force
          } else {
              Write-Host "Direct structure found, moving all contents"
              $sourcePath = "$PWD/temp_python"
              Get-ChildItem -Path $sourcePath | Move-Item -Destination "$PWD/dist/python/" -Force
          }

          # 诊断：查看目标目录内容
          Write-Host "Contents of python directory after extraction:"
          $pythonItems = Get-ChildItem "$PWD/dist/python" -Recurse
          foreach ($item in $pythonItems) {
              if ($item.PSIsContainer) {
                  Write-Host "  [DIR]  $($item.FullName.Replace("$PWD\dist\python\", ''))"
              } else {
                  Write-Host "  [FILE] $($item.Name)"
              }
          }

          # 检查python.exe是否在目标目录
          if (Test-Path "$PWD/dist/python/python.exe") {
              Write-Host "SUCCESS: python.exe found at $PWD/dist/python/python.exe"
          } else {
              Write-Host "ERROR: python.exe NOT FOUND in $PWD/dist/python/"
          }

          # 清理临时目录
          Remove-Item "$PWD/temp_python" -Recurse -Force
          # Find the *_pth file (e.g. python312._pth) and remove it to enable standard site-packages behavior
          $pth = Get-ChildItem -Path "$PWD/dist/python" -Filter "*_pth" -Recurse -File | Select-Object -First 1
          if ($pth) {
            Write-Host "Removing PTH file: $($pth.FullName)"
            Remove-Item $pth.FullName -Force
          } else {
            Write-Host "No _pth file found under dist/python"
          }
          # Ensure pip exists by running get-pip.py
          $gp = "$PWD/get-pip.py"
          Invoke-WebRequest -Uri "https://bootstrap.pypa.io/get-pip.py" -OutFile $gp
          & "$PWD/dist/python/python.exe" $gp
          Remove-Item $gp -Force
          # Copy local env.bat (if present in repo) into dist for packaging
          if (Test-Path "$PWD\env.bat") {
            Copy-Item "$PWD\env.bat" -Destination "$PWD\dist\env.bat" -Force
          }
          if (Test-Path "$PWD\setup.cmd") {
            Copy-Item "$PWD\setup.cmd" -Destination "$PWD\dist\setup.cmd" -Force
          }
          if (Test-Path "$PWD\env.ps1") {
            Copy-Item "$PWD\env.ps1" -Destination "$PWD\dist\env.ps1" -Force
          }

      - name: Setup Portable Python (Unix)
        if: ${{ matrix.os != 'windows-latest' }}
        shell: bash
        run: |
          set -euo pipefail
          url="${{ steps.resolve-python.outputs.python_url }}"
          key="${{ steps.resolve-python.outputs.python_key }}"
          mkdir -p ./dist
          echo "Downloading $url"
          curl -fsSL "$url" -o "./dist/$key"
          mkdir -p ./dist/python
          # Try common archive formats: gz, xz, zip
          if tar -tzf "./dist/$key" >/dev/null 2>&1; then
            tar -xzf "./dist/$key" -C ./dist/python --strip-components=1
          elif tar -tJf "./dist/$key" >/dev/null 2>&1; then
            tar -xJf "./dist/$key" -C ./dist/python --strip-components=1
          else
            unzip -q "./dist/$key" -d ./dist/python || true
          fi
          rm -f "./dist/$key"
          # Ensure python executable is available at ./dist/python/python
          if [ -x ./dist/python/bin/python3 ]; then
            ln -sf "$(pwd)/dist/python/bin/python3" ./dist/python/python
          elif [ -x ./dist/python/python ]; then
            chmod +x ./dist/python/python || true
          elif [ -x ./dist/python/python3 ]; then
            ln -sf "$(pwd)/dist/python/python3" ./dist/python/python
          fi
          if [ -f ./env.sh ]; then
            cp ./env.sh ./dist/env.sh
          fi
          if [ -f ./setup.sh ]; then
            cp ./setup.sh ./dist/setup.sh
            chmod +x ./dist/setup.sh
          fi

      # 2. Download and assemble Zephyr SDK (minimal + arm toolchain)
      - name: Resolve Zephyr SDK release
        id: resolve-sdk
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MATRIX_OS: ${{ matrix.os }}
          MATRIX_ARCH: ${{ matrix.arch }}
        with:
          script: |
            const os = (process.env.MATRIX_OS||'').toLowerCase();
            const arch = (process.env.MATRIX_ARCH||'').toLowerCase();
            async function run(){
              const rels = await github.rest.repos.listReleases({ owner: 'zephyrproject-rtos', repo: 'sdk-ng', per_page: 100 });
              const rel = rels.data.find(r => !r.prerelease);
              if(!rel) return core.setFailed('No non-prerelease release found for zephyrproject-rtos/sdk-ng');
              const tag = rel.tag_name; // e.g. v0.17.4
              const ver = tag.replace(/^v/,'');
              core.setOutput('sdk_tag', tag);
              core.setOutput('sdk_ver', ver);
              const assets = rel.assets || [];

              function findAssetByName(name){
                return assets.find(a => a.name === name) || assets.find(a => a.name && a.name.includes(name));
              }

              let minimalName = '';
              let toolName = '';

              if (os.startsWith('win')) {
                minimalName = `zephyr-sdk-${ver}_windows-x86_64_minimal.7z`;
                toolName = `toolchain_windows-x86_64_arm-zephyr-eabi.7z`;
              } else if (os.includes('ubuntu') || os.includes('linux')) {
                minimalName = `zephyr-sdk-${ver}_linux-x86_64_minimal.tar.xz`;
                toolName = `toolchain_linux-x86_64_arm-zephyr-eabi.tar.xz`;
              } else if (os.includes('mac')) {
                // mac has both arch variants for minimal and toolchain
                if (arch === 'aarch64') {
                  minimalName = `zephyr-sdk-${ver}_macos-aarch64_minimal.tar.xz`;
                  toolName = `toolchain_macos-aarch64_arm-zephyr-eabi.tar.xz`;
                } else {
                  minimalName = `zephyr-sdk-${ver}_macos-x86_64_minimal.tar.xz`;
                  toolName = `toolchain_macos-x86_64_arm-zephyr-eabi.tar.xz`;
                }
              }

              const minimalAsset = findAssetByName(minimalName) || assets.find(a => a.name && a.name.includes('_minimal'));
              const toolAsset = findAssetByName(toolName) || assets.find(a => a.name && a.name.includes('toolchain') && a.name.includes('arm-zephyr-eabi'));

              if (minimalAsset) {
                core.setOutput('minimal_asset', minimalAsset.name);
                core.setOutput('minimal_url', minimalAsset.browser_download_url);
              } else {
                core.setOutput('minimal_asset','');
                core.setOutput('minimal_url','');
              }
              if (toolAsset) {
                core.setOutput('tool_asset', toolAsset.name);
                core.setOutput('tool_url', toolAsset.browser_download_url);
              } else {
                core.setOutput('tool_asset','');
                core.setOutput('tool_url','');
              }
            }
            run().catch(err => core.setFailed(err.message));

      - name: Download and assemble Zephyr SDK (Windows)
        if: ${{ startsWith(matrix.os, 'windows') }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $ver = "${{ steps.resolve-sdk.outputs.sdk_ver }}"
          $min_url = "${{ steps.resolve-sdk.outputs.minimal_url }}"
          $tool_url = "${{ steps.resolve-sdk.outputs.tool_url }}"
          $sdkRoot = Join-Path $PWD 'dist/sdk'
          New-Item -ItemType Directory -Force -Path $sdkRoot | Out-Null
          if (-not $min_url) { Write-Host "No minimal SDK asset url found"; exit 1 }
          Write-Host "Downloading minimal SDK: $min_url"
          $min_file = Join-Path $PWD "dist/$(Split-Path $min_url -Leaf)"
          Invoke-WebRequest -Uri $min_url -OutFile $min_file
          # extract minimal (7z)
          $seven = (Get-Command 7z.exe -ErrorAction SilentlyContinue)?.Source
          if (-not $seven -and (Test-Path 'C:\Program Files\7-Zip\7z.exe')) {
            $seven = 'C:\Program Files\7-Zip\7z.exe'
          }
          if (-not $seven) { Write-Host "7z.exe not found in PATH or default install location"; exit 1 }
          $resolvedMin = (Resolve-Path $min_file).Path
          Add-Content -Path $env:GITHUB_ENV -Value "MIN_SDK_ARCHIVE=$resolvedMin"
          
          # Extract to temp dir to handle potential nested structure
          $tempSdkDir = Join-Path $PWD 'dist/temp_sdk'
          if (Test-Path $tempSdkDir) { Remove-Item $tempSdkDir -Recurse -Force }
          New-Item -ItemType Directory -Force -Path $tempSdkDir | Out-Null
          
          & $seven x $resolvedMin "-o$tempSdkDir" -y | Out-Null
          if ($LASTEXITCODE -ne 0) {
            throw "7z extraction of $resolvedMin failed with exit code $LASTEXITCODE"
          }

          $sdkDir = Join-Path $sdkRoot "zephyr-sdk-$ver"
          if (Test-Path $sdkDir) { Remove-Item $sdkDir -Recurse -Force }

          $extractedDir = Get-ChildItem -Path $tempSdkDir -Directory | Where-Object { $_.Name -like "zephyr-sdk-*" } | Select-Object -First 1
          if ($extractedDir) {
             Write-Host "Moving extracted SDK from $($extractedDir.FullName) to $sdkDir"
             Move-Item -Path $extractedDir.FullName -Destination $sdkDir
          } else {
             throw "Could not find zephyr-sdk-* directory in minimal archive"
          }
          Remove-Item $tempSdkDir -Recurse -Force

          Get-ChildItem -Path $sdkDir -Filter 'zephyr-sdk-*hosttools-standalone*.sh' -Recurse -ErrorAction SilentlyContinue | Remove-Item -Force
          if (-not (Get-ChildItem -Path $sdkDir -Recurse -File -ErrorAction SilentlyContinue | Select-Object -First 1)) {
          Write-Host "Extraction produced no files; listing ${sdkDir}:"
          Get-ChildItem -Path $sdkDir -Force | ForEach-Object { Write-Host "  $($_.FullName)" }
          throw "Zephyr SDK directory ${sdkDir} is empty after extracting $resolvedMin"
          }
          # download toolchain
          if (-not $tool_url) { Write-Host "No toolchain asset found"; exit 1 }
          $tool_file = Join-Path $PWD "dist/$(Split-Path $tool_url -Leaf)"
          Invoke-WebRequest -Uri $tool_url -OutFile $tool_file
          # extract toolchain into tmp and move arm-zephyr-eabi under sdk folder
          $resolvedTool = (Resolve-Path $tool_file).Path
          Add-Content -Path $env:GITHUB_ENV -Value "TOOL_SDK_ARCHIVE=$resolvedTool"
          $tmpTool = Join-Path $PWD 'dist/tmp_tool'
          New-Item -ItemType Directory -Force -Path $tmpTool | Out-Null
          Push-Location $tmpTool
          & $seven x $resolvedTool "-o$tmpTool" -y | Out-Null
          $toolExit = $LASTEXITCODE
          Pop-Location
          if ($toolExit -ne 0) {
            throw "7z extraction of $resolvedTool failed with exit code $toolExit"
          }
          $dir = Get-ChildItem -Path $tmpTool -Directory | Select-Object -First 1
          if ($dir) {
            Move-Item -Path $dir.FullName -Destination (Join-Path $sdkDir $dir.Name) -Force
          }
          Remove-Item $tmpTool -Recurse -Force

      - name: Download and assemble Zephyr SDK (Unix)
        if: ${{ matrix.os != 'windows-latest' }}
        shell: bash
        run: |
          set -euo pipefail
          ver="${{ steps.resolve-sdk.outputs.sdk_ver }}"
          min_url="${{ steps.resolve-sdk.outputs.minimal_url }}"
          tool_url="${{ steps.resolve-sdk.outputs.tool_url }}"
          mkdir -p ./dist
          if [ -z "$min_url" ]; then echo "No minimal SDK url found"; exit 1; fi
          echo "Downloading minimal SDK: $min_url"
          min_file="./dist/$(basename "$min_url")"
          curl -fsSL "$min_url" -o "$min_file"
          sdk_root="./dist/sdk"
          mkdir -p "$sdk_root"
          min_abs="$(cd "$(dirname "$min_file")" && pwd)/$(basename "$min_file")"
          echo "MIN_SDK_ARCHIVE=$min_abs" >> "$GITHUB_ENV"
          tmp_sdk_extract="./dist/tmp_sdk_extract"
          rm -rf "$tmp_sdk_extract"
          mkdir -p "$tmp_sdk_extract"
          # extract minimal (tar.xz or tar.gz)
          if tar -tJf "$min_file" >/dev/null 2>&1; then
            tar -xJf "$min_file" -C "$tmp_sdk_extract"
          else
            tar -xzf "$min_file" -C "$tmp_sdk_extract" || true
          fi
          extracted=$(find "$tmp_sdk_extract" -maxdepth 1 -type d -name 'zephyr-sdk-*' | head -n1 || true)
          if [ -z "$extracted" ]; then
            echo "No zephyr-sdk-* directory found in $tmp_sdk_extract. Contents:"
            find "$tmp_sdk_extract" -maxdepth 1 -mindepth 1 -print || true
            extracted="$tmp_sdk_extract/zephyr-sdk-${ver}"
            rm -rf "$extracted"
            mkdir -p "$extracted"
            find "$tmp_sdk_extract" -mindepth 1 -maxdepth 1 ! -path "$extracted" -exec mv {} "$extracted/" \;
          fi
          sdk_dir="$sdk_root/zephyr-sdk-${ver}"
          rm -rf "$sdk_dir"
          mkdir -p "$(dirname "$sdk_dir")"
          mv "$extracted" "$sdk_dir"
          rm -f "$sdk_dir"/zephyr-sdk-*hosttools-standalone*.sh 2>/dev/null || true
          rm -rf "$tmp_sdk_extract"
          rm -f "$sdk_dir"/zephyr-sdk-*hosttools-standalone*.sh 2>/dev/null || true
          # download toolchain
          if [ -z "$tool_url" ]; then echo "No toolchain asset found"; exit 1; fi
          echo "Downloading toolchain: $tool_url"
          tool_file="./dist/$(basename "$tool_url")"
          curl -fsSL "$tool_url" -o "$tool_file"
          tool_abs="$(cd "$(dirname "$tool_file")" && pwd)/$(basename "$tool_file")"
          echo "TOOL_SDK_ARCHIVE=$tool_abs" >> "$GITHUB_ENV"
          tmp_tool="./dist/tmp_tool"
          mkdir -p "$tmp_tool"
          if tar -tJf "$tool_file" >/dev/null 2>&1; then
            tar -xJf "$tool_file" -C "$tmp_tool" || true
          else
            tar -xzf "$tool_file" -C "$tmp_tool" || true
          fi
          # move the first directory from tmp_tool into the sdk folder
          firstdir=$(find "$tmp_tool" -maxdepth 1 -type d ! -path "$tmp_tool" | head -n1)
          if [ -n "$firstdir" ]; then
            mv "$firstdir" "$sdk_dir/"
          fi
          rm -rf "$tmp_tool"

      # 3. 准备系统工具 (Windows Only)
      - name: Setup Windows Tools
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $base = Join-Path $PWD 'dist'
          New-Item -ItemType Directory -Force -Path $base | Out-Null
          New-Item -ItemType Directory -Force -Path (Join-Path $base 'bin') | Out-Null
          New-Item -ItemType Directory -Force -Path (Join-Path $base 'cmake') | Out-Null
          New-Item -ItemType Directory -Force -Path (Join-Path $base 'gperf') | Out-Null
          New-Item -ItemType Directory -Force -Path (Join-Path $base 'mingit') | Out-Null
          New-Item -ItemType Directory -Force -Path (Join-Path $PWD 'dist/downloads') | Out-Null

          function Download-And-Extract($url, $destDir) {
            $uri = [uri]$url
            $name = [System.IO.Path]::GetFileName($uri.LocalPath)
            if ([string]::IsNullOrEmpty($name)) { $name = [Guid]::NewGuid().ToString() + '.zip' }
            $out = Join-Path $PWD "dist/downloads/$name"
            Write-Host "Downloading $url to $out"
            Invoke-WebRequest -Uri $url -OutFile $out
            Write-Host "Extracting $out to $destDir"
            Expand-Archive -Path $out -DestinationPath $destDir -Force
          }

          # CMake
          $cmake_url = 'https://github.com/Kitware/CMake/releases/download/v4.2.1/cmake-4.2.1-windows-x86_64.zip'
          Download-And-Extract $cmake_url (Join-Path $base 'cmake')
          $cmakeRoot = Join-Path $base 'cmake'
          $cmakeDirs = Get-ChildItem -Path $cmakeRoot -Directory
          if ($cmakeDirs.Count -eq 1 -and $cmakeDirs[0].Name -like 'cmake-*') {
            Get-ChildItem -Path $cmakeDirs[0].FullName | Move-Item -Destination $cmakeRoot -Force
            Remove-Item $cmakeDirs[0].FullName -Recurse -Force
          }

          # Ninja (single binary) -> place in bin
          $ninja_url = 'https://github.com/ninja-build/ninja/releases/download/v1.13.2/ninja-win.zip'
          $tmpNinja = Join-Path $PWD 'dist/downloads/ninja.zip'
          Invoke-WebRequest -Uri $ninja_url -OutFile $tmpNinja
          Expand-Archive -Path $tmpNinja -DestinationPath (Join-Path $base 'bin') -Force

          # gperf
          $gperf_url = 'https://gigenet.dl.sourceforge.net/project/gnuwin32/gperf/3.0.1/gperf-3.0.1-bin.zip?viasf=1'
          Download-And-Extract $gperf_url (Join-Path $base 'gperf')

          # MinGit
          $mingit_url = 'https://github.com/git-for-windows/git/releases/download/v2.52.0.windows.1/MinGit-2.52.0-64-bit.zip'
          Download-And-Extract $mingit_url (Join-Path $base 'mingit')

          # wget (single binary) -> place in bin
          $wget_url = 'https://eternallybored.org/misc/wget/releases/wget-1.21.4-win32.zip'
          $tmpWget = Join-Path $PWD 'dist/downloads/wget.zip'
          Invoke-WebRequest -Uri $wget_url -OutFile $tmpWget
          Expand-Archive -Path $tmpWget -DestinationPath (Join-Path $base 'bin') -Force

          Write-Host "Windows dependencies downloaded to $base"

      # 4. 离线 Wheel 包下载 (关键步骤)
      - name: Create Offline Wheels (Windows)
        if: ${{ startsWith(matrix.os, 'windows') }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          New-Item -ItemType Directory -Force -Path ./dist/wheels | Out-Null

          # 下载 requirements 文件
          $reqs = @("requirements.txt", "requirements-base.txt", "requirements-build-test.txt", "requirements-run-test.txt", "requirements-extras.txt", "requirements-compliance.txt")
          foreach ($r in $reqs) {
              Invoke-WebRequest -Uri "https://raw.githubusercontent.com/zephyrproject-rtos/zephyr/main/scripts/$r" -OutFile "./dist/$r"
          }

          $distDir = "${{ github.workspace }}\dist"
          $pythonDir = Join-Path $distDir "python"

          # 由于压缩包中确实有python.exe，我们需要使用正确路径
          $pythonCmd = Join-Path $pythonDir "python.exe"

          # 1. 确保 pip wheel 自身是最新的
          & $pythonCmd -m pip install --upgrade pip setuptools wheel poetry-core

          # 2. 【核心修改】使用 pip wheel 而不是 pip download
          # 不指定 --platform, 不指定 --python-version (使用原生环境)
          # 这会自动把源码包编译成 wheel
          & $pythonCmd -m pip wheel west -r ./dist/requirements.txt -w ./dist/wheels

      - name: Create Offline Wheels (Unix)
        if: ${{ matrix.os != 'windows-latest' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ./dist/wheels

          # 下载 requirements 文件
          base_url="https://raw.githubusercontent.com/zephyrproject-rtos/zephyr/main/scripts"
          for r in requirements.txt requirements-base.txt requirements-build-test.txt requirements-run-test.txt requirements-extras.txt requirements-compliance.txt; do
              curl -fsSL "$base_url/$r" -o "./dist/$r"
          done

          PY="${{ github.workspace }}/dist/python/python"
          echo "Using python: $PY"

          # 1. 确保构建工具就位
          "$PY" -m pip install --upgrade pip setuptools wheel poetry-core

          # 2. 【核心修改】使用 pip wheel
          # 移除 --platform 和 --python-version 限制
          # 让它利用 Runner 的环境编译出完美的 Wheel
          "$PY" -m pip wheel west -r ./dist/requirements.txt -w ./dist/wheels

      # 5. 清理临时文件
      - name: Cleanup (Windows)
        if: ${{ startsWith(matrix.os, 'windows') }}
        shell: pwsh
        run: |
          if (Test-Path './dist/downloads') { Remove-Item './dist/downloads' -Recurse -Force }
          foreach ($path in @($env:MIN_SDK_ARCHIVE, $env:TOOL_SDK_ARCHIVE)) {
            if ($path -and (Test-Path $path)) { Remove-Item $path -Force }
          }

      - name: Cleanup (Unix)
        if: ${{ matrix.os != 'windows-latest' }}
        shell: bash
        run: |
          rm -rf ./dist/downloads 2>/dev/null || true
          if [ -n "${MIN_SDK_ARCHIVE:-}" ] && [ -f "$MIN_SDK_ARCHIVE" ]; then rm -f "$MIN_SDK_ARCHIVE"; fi
          if [ -n "${TOOL_SDK_ARCHIVE:-}" ] && [ -f "$TOOL_SDK_ARCHIVE" ]; then rm -f "$TOOL_SDK_ARCHIVE"; fi

      # 6. 上传 Artifact (目录)
      - uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: dist

  release:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Package Assets
        run: |
          mkdir -p release-assets
          for dir in artifacts/*; do
            if [ -d "$dir" ]; then
              name=$(basename "$dir")
              echo "Packaging $name..."
              if [[ "$name" == *"windows"* ]]; then
                (cd "$dir" && zip -r -q "../../release-assets/${name}.zip" .)
              else
                (cd "$dir" && tar -czf "../../release-assets/${name}.tar.gz" .)
              fi
            fi
          done
          ls -l release-assets

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: release-assets/*
